排序感觉是老生常谈的东西，但实际上不同的排序方法包含了不同的思想/结构。真正理解了它们，就可以不光对线性表排序，链表等结构亦可以使用。

本文实例代码位于`java/gists/Sorts.java`文件中。

## 归并

> 复杂度：
>
> * 时间：O(nlogn)
> * 空间：从顶向下——O(logn)；从底向上——O(1)





## 堆排

> 复杂度：
>
> * 时间：O(nlogn)
> * 空间： 

### 原理

这里的**堆其实是一棵完全二叉树（即所有节点按照从左到右、从上到下的顺序组织）**。可分为大顶堆（根节点大于左、右子树）、小顶堆（根节点小于左、右子树）。

> **排序思路**：
>
> 先根据目的将原数组调整成大/小顶堆，再将顶部元素与数组末尾元素交换；再继续调整剩下的树，完了再将顶部元素置于数组末尾；如此反复，直到数组有序。因此，**升序使用大顶堆，降序使用小顶堆**。

初始思路【错误】：对数组逆序遍历，每个子节点与它的父节点比较一次，比它大则交换；这就模拟了一个树的后序遍历过程。但这样**只保证了根节点是大顶的，不能保证每个子树也是大顶的**。代码如果写成这样，可就错了：
![image-20210305123923381](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305123930.png)

这个写法实际是变形的选择排序，即每次将前`j`个元素的最大值置于堆顶，再调换为数组尾部。当然能获得正确结果，但复杂度O(n^2)，而且大顶堆的特性未被利用到。

正确思路：

1. 【调整方法】当一个新元素被放到已经建好的大顶堆根节点时，它可能无需调整（如与左、右子节点相等），可能小于它的子节点。根据特性，我们应当选择最大者与它交换，假设是左子节点，再进入它的左子树并调整（这个递归过程在线性表中可以借助下标完成，故无需使用额外栈空间）。
2. 【构建方法】从最后一个节点的父节点开始，逆序遍历数组（相当于后序遍历），挨个调整这些父节点（因为是后序，所以它的子树已经是大顶堆了）。

这样做的好处就是调整时利用了大顶堆的特性，即**一个节点不满足条件时只与1/2的子节点（选左或者选右）有关，最多比较logn次完成调整**。

示例如下：

【原始数组】

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305161505.png)

【构造/调整过程】

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305161544.png)

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305161600.png)

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305161619.png)

【交换/调整过程】

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305162253.png)

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305162311.png)

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305162322.png)

![img](https://llf-oss.oss-cn-beijing.aliyuncs.com/bucket/pictures/20210305162331.png)

### 代码

```java
/** 
*   交换函数
*/
void swap(int[] arr, int a, int b){
    int t = arr[a];
    arr[a] = arr[b];
    arr[b] = t;
}

/** 
*   建堆函数
*/
void BuildHeap(int[] nums){
    for(int j = (nums.length-2)>>1;j>=0;j--){
        AdjustHeap(nums, j, nums.length-1);
    }
}

/**
*   调整函数
*/
void AdjustHeap(int[] nums, int start, int end){
    for(int k = start; 2*k+1<=end; ){
        // 右子节点存在且大于左子节点
        if(2*k+2<=end && nums[2*k+1]< nums[2*k+2]){
            if(nums[k]<nums[2*k+2]){
                // 交换，并移动
                swap(nums, k , 2*k+2);
                k = 2*k +2;
            }
            else{   // 不用调整
                break;
            }
        }
        // 右子节点不存在或者没有左子节点大
        else if(nums[k]<nums[2*k+1]){
            // 交换，并移动
            swap(nums, k , 2*k+1);
            k = 2*k +1;
        }
        else{   // 不用调整
            break;
        }
    }
}

void HeapSort(int[] nums){
    BuildHeap(nums);
    for(int j= nums.length-1;j>=1;j--){
        // 交换头尾
        swap(nums, j, 0);
        // 头元素变化，重新调整，并缩短范围
        AdjustHeap(nums, 0, j-1);
    }
}
```


## 快排


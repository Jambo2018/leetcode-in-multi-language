## 总述

**动态规划问题的一般形式是求最值**。动规其实是运筹学中的一种最优化方法，常用于解决计算机问题，其本身也是种特殊的**穷举方法**。

特点：

1. 存在**重叠子问题**：即在计算过程中，有些子问题被重复计算，因此我们使用辅助空间记录这些中间结果。
2. 存在**最优子结构**：一般问题可被剥离成一堆更小的同构的子问题，正因如此，我们才能通过子问题的最优化解法得到问题的最值。
3. 通过**状态转移方程**求解：接上一特点，状态转移方程是子问题到大问题转换的桥梁。

基本上分析透了这三条一个动规问题也就迎刃而解了。

## 例题1：最长回文子串

> 问题描述：给你一个字符串 `s`，找到 `s` 中最长的回文子串。
>
> ```
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> ```

**分析：**

假设一个字符串是回文串，则它在去掉两头字符后依旧是回文串。我们用`dp[i][j]`代表一个下标从`i`到`j`的子串，前一条件可被表达为：`dp[i][j]=dp[i+1][j-1]=dp[i+2][j-2]=... && dp[i]==dp[j] && dp[i+1]==dp[j-1] && dp[i+2]==dp[j-2] && ...`。

另外，当字串长度小于等于3时，是否回文串可直接判别：

- `len = 1`时，肯定是啦
- `len = 2`时， 两头相等就是
- `len = 3`时， 两头相等即可，中间字符无所谓

因此，可只`j-i<3, dp[i]==dp[j] ==> dp[i][j]=true`，由此可得初始条件。

**解答：**

我们直接用一个二维数组存储特定下标区间内是否为回文串，以`tabcba`为例，从`i=0，j=1`开始计算，结果如下：

![image-20210129105715504](https://i.loli.net/2021/01/29/VsLBy6l8RYDxd7w.png)

值得一提的是，对角线元素必为1，实际上矩阵只用了一半，如下的代码中，我们通过for循环下标限制了`j>i`：

```java
for(int j = 1; j <len ;j ++){
    for(int i  = 0 ;i< j ;i++) {
        if (s.charAt(i) != s.charAt(j))
            continue;
        if (j-i<3)
            matrix[i][j] = 1;
        else
            // 相等则判断下一级
            matrix[i][j] = matrix[i+1][j-1];
        if(matrix[i][j]==1 && (j-i)>(end-start)){
            start = i;
            end = j;
        }
    }
}
```

也就是说实际的填表过程是一列一列的填，在计算`dp[2][4]`时它满足两头相同且`j-i<3`的条件，所以为true；而到了计算`dp[1][5]`时因为两头字符相同，其结果等于`dp[2][4]`，所以它也是true。由此可知最大回文串区间为`[1,5]`，对原字符串做截取即可。

**补充：**

虽然本题用动规写代码十分简洁，但分析其复杂度可知：时间复杂度`O(n^2)`，空间复杂度`O(n^2)`。相对于**中心扩散法**（时间复杂度`O(n^2)`，空间复杂度`O(1)`）来说，优势不够，所以未必动规就是最好解法。

## 例题2：最大子序和

> 问题描述：给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```

### 解法一：O(n^2)

如下例：以数组`[8, -19, 5, -1, 20]`的前三元素为例，用一个辅助变量`max`记录子序最大值，一个等长数组`array`记录中间结果。

![image-20210201103540907](https://i.loli.net/2021/02/01/KYrEyzOwjkQ9q2v.png)

- i=1时只有一各子序列，`max`就是它本身

- i=2时变成3个子序列`[8]`，`[8, -19]`，`[-19]`，因为第一个子序已经做过比较，故不保存，我们只在辅助数组的对应位置中记录后两个数组的累加和，同时更新`max`
- i=3时变成6个子序列，前3个已经分析过，后3个是加入了元素5后产生的，如上图，将辅助数组对应位置更新后3个数组的累加和。同时更新`max`
- 以此类推后面的数组...

时间复杂度：1+2+3+...+n = n*(n+1)/2 ，即O(n^2)

空间复杂度： O(n)

### 解法二：贪心（发现规律）

策略：**当前面的序列和为负数时，则认为对最终结果不利，因此从当前结果重新计数。** P.S. 这里不关注前面序列和的“涨跌”，是因为只要它是正数，就有可能被新节点带到最大值的可能（亦有可能被新来的节点带入一个极小值，但没关系，因为`max`变量/`array`数组已经对前面的极大值做了记录）；但反过来，前面序列为负数，肯定不会被最大序列接受，因为它只会拉低总和。

![image-20210201151140241](https://i.loli.net/2021/02/01/gtE8xKByU2pJPkr.png)

如上，当遍历到达5时，前面序列和为-11（已经不可能计入最大和序列）；故重新计数，直到20时获得了最大和24。

```java
public int maxSubArray(int[] nums) {
    int[] accum = new int[nums.length];
    accum[0] = nums[0];
    int max = accum[0];
    for(int i=1;i<nums.length; i++){
        if(accum[i-1]<0)
            accum[i] = nums[i];
        else
            accum[i] = nums[i]+ accum[i-1];
        if(accum[i]>max)
            max = accum[i];
    }
    return max;
}
```

时间复杂度：O(n)

空间复杂度：O(n)

### 解法三：动规（换角度思考）

策略：我们用`f(i)`代表以**第`i`位元素结尾的子序列**累加和最大值，则`f(i+1)=max{f(i), nums[i+1]}`，我们所求的**最大序列和就是`f(i)`的最大值**。P.S. 对于以当前下标结尾的元素，其最大和就两种情况：一、延续前一序列，即以`i-1`结尾的序列和叠加当前元素；二、重新开始，留一个当前元素为唯一元素的序列。

![image-20210201172628046](https://i.loli.net/2021/02/01/H365CP4YAnLIKBg.png)

以上图为例：在到达左侧第一个1时，因为累加和为-1，没有1大，我们选1重新开始；在到达4时，如果续前面的序列，则和为2，没有4大，我们再次从4重新开始；最后遍历辅助数组，获得最大值。

```java
fdfd
```

观察发现：**辅助数组`f(i)`元素总小于等于原数组，相等意味着抛弃前面序列，从当前元素重新开始。**

### 解法四：分治（别出心裁）

分：同二分法，`(start+end)>>1`，从中间划分成两个区间，不断细化直到剩一个元素。

治：难点，需要维护4个变量：对于区间`[l, r]`，假设从中间点`m`划分，`lSum`代表以`l`号元素开头的子序的最大和，`rSum`代表以`r`号元素结尾子序的最大和，`iSum`代表区间和，`mSum`代表区间内最大和。

![image-20210203102951813](https://i.loli.net/2021/02/03/9dU4sykmGZ7lzBD.png)

如上图，完整的序列来说：`lSum`是`[8, -19, 5, -1, 20]=13`，`rSum`是`[5, -1, 20]=24`，`iSum`是完整序列`lSum=13`，`mSum`这里等于跨域了中间点，即`left.rSum+right.lSum=24`。搞清楚这些概念，合并时有4条更新规则：

1. 区间和`iSum`等于左子区间和与右子区间和的累加；
2. 左子区间`lSum`有两种可能：一、维持现状；二、跨越左子区间和右子区间的`lSum`拼接，比较后取大值；
3. 右子区间`rSum`同上；
4. 区间最大和`mSum`有三种可能：一、分布在左子区间，则选左子区间最大和；二、分布在右子区间，则选右子区间最大和；三、跨越了中间节点，则选`left.rSum+right.lSum`，比较后取大值。

```java
/**
     * 分治思想：精彩！详见algorithms/经典动态规划.md
     * @param start 区间开始下标
     * @param end 区间结束下标
     * @param nums 数组
     * @return 返回值是一个四元数组，分别代表lSum, rSum, mSum, iSum
     */
public int[] splitAndBuild(int start, int end, int[] nums){
    if (start == end)
        return new int[]{nums[start], nums[start], nums[start], nums[start]};
    int mid = (start+end)>>1;
    int[] left = splitAndBuild(start, mid, nums);
    int[] right = splitAndBuild(mid+1, end, nums);
    // 开始合并
    int lSum = Math.max(left[0], left[3]+right[0]);
    int rSum = Math.max(right[1], right[3]+left[1]);
    int iSum = left[3]+right[3];
    int mSum = Math.max(Math.max(left[2], right[2]),left[1]+right[0]);
    return new int[]{lSum, rSum, mSum, iSum};
}
```


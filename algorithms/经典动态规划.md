## 总述

**动态规划问题的一般形式是求最值**。动规其实是运筹学中的一种最优化方法，常用于解决计算机问题，其本身也是种特殊的**穷举方法**。

特点：

1. 存在**重叠子问题**：即在计算过程中，有些子问题被重复计算，因此我们使用辅助空间记录这些中间结果。
2. 存在**最优子结构**：一般问题可被剥离成一堆更小的同构的子问题，正因如此，我们才能通过子问题的最优化解法得到问题的最值。
3. 通过**状态转移方程**求解：接上一特点，状态转移方程是子问题到大问题转换的桥梁。

基本上分析透了这三条一个动规问题也就迎刃而解了。

## 例题1：最长回文子串

> 问题描述：给你一个字符串 `s`，找到 `s` 中最长的回文子串。
>
> ```
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> ```

**分析：**

假设一个字符串是回文串，则它在去掉两头字符后依旧是回文串。我们用`dp[i][j]`代表一个下标从`i`到`j`的子串，前一条件可被表达为：`dp[i][j]=dp[i+1][j-1]=dp[i+2][j-2]=... && dp[i]==dp[j] && dp[i+1]==dp[j-1] && dp[i+2]==dp[j-2] && ...`。

另外，当字串长度小于等于3时，是否回文串可直接判别：

- `len = 1`时，肯定是啦
- `len = 2`时， 两头相等就是
- `len = 3`时， 两头相等即可，中间字符无所谓

因此，可只`j-i<3, dp[i]==dp[j] ==> dp[i][j]=true`，由此可得初始条件。

**解答：**

我们直接用一个二维数组存储特定下标区间内是否为回文串，以`tabcba`为例，从`i=0，j=1`开始计算，结果如下：

![image-20210129105715504](https://i.loli.net/2021/01/29/VsLBy6l8RYDxd7w.png)

值得一提的是，对角线元素必为1，实际上矩阵只用了一半，如下的代码中，我们通过for循环下标限制了`j>i`：

```java
for(int j = 1; j <len ;j ++){
    for(int i  = 0 ;i< j ;i++) {
        if (s.charAt(i) != s.charAt(j))
            continue;
        if (j-i<3)
            matrix[i][j] = 1;
        else
            // 相等则判断下一级
            matrix[i][j] = matrix[i+1][j-1];
        if(matrix[i][j]==1 && (j-i)>(end-start)){
            start = i;
            end = j;
        }
    }
}
```

也就是说实际的填表过程是一列一列的填，在计算`dp[2][4]`时它满足两头相同且`j-i<3`的条件，所以为true；而到了计算`dp[1][5]`时因为两头字符相同，其结果等于`dp[2][4]`，所以它也是true。由此可知最大回文串区间为`[1,5]`，对原字符串做截取即可。

**补充：**

虽然本题用动规写代码十分简洁，但分析其复杂度可知：时间复杂度`O(n^2)`，空间复杂度`O(n^2)`。相对于**中心扩散法**（时间复杂度`O(n^2)`，空间复杂度`O(1)`）来说，优势不够，所以未必动规就是最好解法。
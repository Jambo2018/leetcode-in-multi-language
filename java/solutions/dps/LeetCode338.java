package solutions.dps;

public class LeetCode338 {

    /**
     * 解法一：
     *     常规套路，对n内每个数字做二进制位的1个数计数
     *
     * 解法二（动态规划一）：
     *     就是我写的这个，既然用了动规，我们将dp[i]与前面的结果联系起来——对num右移一下发现在dp中已有结果，
     * 我们只需判断被抹掉的这一位是否是1即可，即num&1，二者相加即结果。
     *
     * 解法三（动态规划二）：
     *     观察数组的变化规律就发现2^0、2^1、2^2等都是10xx格式，结果必为1。因此，让num减去离他最近的2的
     * 整数幂，剩余结果只比dp[i]少了个1，判断2的整数幂可以用num&(num-1)=0决定。
     *
     * 解法四（动态规划三）：
     *     基于一个有意思的算法，num&(num-1)得到的值会将num最右侧的1清零，如：10(1010) & 9(1001)= 1000(8)，
     * 8(1000) & 7(0111)=0，而且计算结果只会比num小，所以将它的dp值加一即可。
     *
     *
     * @param num
     * @return
     */
    public int[] countBits(int num) {
        int[] dp  = new int[num+1];
        dp[0] = 0;
        for(int i = 1 ;i<=num;i++){
            dp[i] = dp[i>>1]+(i&1); // 判断最右侧一位是否为1
        }
        return dp;
    }

}

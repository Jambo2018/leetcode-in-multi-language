package solutions.dps;

public class LeetCode70 {

    /**
     * 站在第n层台阶上，它可以是从前一步跨了1阶上来的，也可能是垮了2阶上来的，故它的走法是这两种走法的总和。
     *
     * 空间复杂度优化： 因为dp是一维数组，而当前元素只与前两元素有关，可用两个变量存储，并保持更新，此时为O(1)。
     * @param n 台阶数
     * @return 走法数目
     */
    public int climbStairs(int n) {

        int[] dp = new int[n+1];
        // 设置初始条件
        dp[1] =1;
        if(n>1){
            // 一次跨2步和跨了2次一步
            dp[2] =2;
            for(int i =3;i<=n;i++)
                dp[i]= dp[i-1]+dp[i-2];
        }

        return dp[n];
    }

    /**
     *  数学推导法：
     *  方法一： （线性代数不好的还是放弃吧）
     *  ( Fn+1 ) = [ 1 1 ]( Fn   )
     *  ( Fn   )   [ 1 0 ]( Fn-1 )
     *  设转移矩阵为M， 则最终结果为 M^n * [0 1]， 计算M ^n 时可用快速幂算法，巴拉巴拉
     *
     *  方法二： 通项公式
     *  状态转移方程依旧如上，但在计算时，可以对M对角化， 即 M= SYS^-1, 则 M^n = SY^nS^-1， 在计算特征值，简化过程。
     *  （我tm全忘了呀！）
     */
}

package solutions.others;

import util.SolutionsFacade;

public class LeetCode169 {

    /**
     * 计数法（专业叫法：摩尔投票法），根据题意，出现次数超过总数一半的数就是多数
     * 从数量角度看，每个不同的元素个数对多数抵消过后，其所剩数量之稍大于一。
     * 所以：我们从第一个元素开始计数，若和候选元素相同则加一，不同则减一，当计数为0时换一个候选元素，从上一行定理可知最终元素必为多数！
     * @param nums
     * @return
     */
    public int majorityElement(int[] nums) {
        int k = 0, res = nums[0];
        for(int i=0;i<nums.length;i++){
            if(k==0){
                res = nums[i];
                k ++;
                continue;
            }

            if(nums[i]!=res)
                k--;
            else
                k++;
        }
        return res;
    }


    /**
     * 其他解法：
     * 一、哈希表：将数组每个元素及出现次数用HashMap记录下来，最后遍历一下Map找到最大的计数最大值对应的key。
     * 二、排序法：将数组升序或降序排列，再提取[n/2]的中间元素即为多数。
     * 三、随机法：从概率学角度说，随便选个数时是多数的可能性较高，因此，每次随个数验证一下即可，其时间复杂度仅可期望衡量。验证细节不表。
     * 四：分治法：
     * 先说定理：若一个数是数组的众数，它必是数组切分后左/右序列至少之一的众数（可用反证法说明）
     * 例子： [3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5]
     * 分：2分，不用多说
     * 治：区间只剩一个元素时即它本身，这不用说；左、右连个区间合并时，若是同一个数字，直接返回它；
     * 若不同，比较它们二者的众数在新区间的出现次数，返回较大者。
     *
     * 时间复杂度：O(nlogn)   合并过程中：T(n) =2T(n/2) + 2n（左众数扫描一遍、右众数扫描一遍）
     * 空间复杂度：O(logn)
     */
}
